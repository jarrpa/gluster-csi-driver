package heketi

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"net/url"
	"os"
	"strings"
	"testing"

	"github.com/gluster/gluster-csi-driver/pkg/command"

	"github.com/golang/glog"
	hapi "github.com/heketi/heketi/pkg/glusterfs/api"
	"github.com/kubernetes-csi/csi-test/pkg/sanity"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
	"k8s.io/client-go/kubernetes/scheme"
)

const (
	CSIDriverName = "glusterfs.gluster.org"
)

var volumeCache = make(map[string]hapi.VolumeInfoResponse)
var TestVolName = "heketidbstorage"
var TestVolID = "heketidbstorage-heketi"
var TestVolSize = 1000

func TestDriverSuite(t *testing.T) {
	socket := "/tmp/csi.sock"
	endpoint := "unix://" + socket

	//cleanup socket file if already present
	os.Remove(socket)

	_, err := os.Create(socket)
	if err != nil {
		t.Fatal("Failed to create a socket file")
	}
	defer os.Remove(socket)

	ks := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case "GET":
			handleKubeGETRequest(w, r, t)
			return

		case "DELETE":
			w.WriteHeader(http.StatusNoContent)
			return

		case "POST":
			handlePOSTRequest(w, r, t)
			return
		}
	}))
	defer ks.Close()

	kubeURL, err := url.Parse(ks.URL)
	if err != nil {
		t.Fatal(err)
	}
	kubeAddr := strings.Split(kubeURL.Host, ":")
	os.Setenv("KUBERNETES_SERVICE_HOST", kubeAddr[0])
	os.Setenv("KUBERNETES_SERVICE_PORT", kubeAddr[1])

	volumeCache[TestVolID] = hapi.VolumeInfoResponse{
		VolumeInfo: hapi.VolumeInfo{
			VolumeCreateRequest: hapi.VolumeCreateRequest{
				Name: TestVolName,
				Size: TestVolSize,
			},
			Id: TestVolID,
		},
		Bricks: []hapi.BrickInfo{},
	}

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case "GET":
			handleGETRequest(w, r, t)
			return

		case "DELETE":
			handleDELETERequest(w, r, t)
			return

		case "POST":
			handlePOSTRequest(w, r, t)
			return
		}
	}))
	defer ts.Close()

	url, err := url.Parse(ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	volumeParameters := map[string]string{
		"glusterurl": url.String(),
	}

	config := &command.Config{
		Name:     CSIDriverName,
		Endpoint: endpoint,
		NodeID:   "testing",
	}

	d := New(config)

	go d.Run()

	mntStageDir := "/tmp/mntStageDir"
	mntDir := "/tmp/mntDir"
	defer os.RemoveAll(mntStageDir)
	defer os.RemoveAll(mntDir)

	cfg := &sanity.Config{
		Roles: sanity.DriverRoles{
			sanity.DriverRoleController,
			sanity.DriverRoleIdentity,
		},
		StagingPath:          mntStageDir,
		TargetPath:           mntDir,
		Address:              endpoint,
		TestVolumeParameters: volumeParameters,
	}

	sanity.Test(t, cfg)
}

func handleKubeGETRequest(w http.ResponseWriter, r *http.Request, t *testing.T) {
	if strings.Contains(r.URL.String(), "persistentvolumes") {
		//writeResp(w, http.StatusOK, &corev1.PersistentVolumeList{}, t)
		responsewriters.WriteObject(http.StatusOK, corev1.SchemeGroupVersion, scheme.Codecs, &corev1.PersistentVolumeList{}, w, r)
		return
	}

	writeResp(w, http.StatusNotFound, nil, t)
}

func handleGETRequest(w http.ResponseWriter, r *http.Request, t *testing.T) {
	glog.Errorf("GET URL: %s", r.URL.String())
	if strings.HasSuffix(r.URL.String(), "/hello") {
		writeResp(w, http.StatusOK, nil, t)
		return
	}

	if strings.HasSuffix(r.URL.String(), "/volumes") {
		vols := []string{}
		for vol := range volumeCache {
			vols = append(vols, vol)
		}
		resp := hapi.VolumeListResponse{
			Volumes: vols,
		}
		writeResp(w, http.StatusOK, resp, t)
		return
	}

	if strings.HasSuffix(r.URL.String(), "/clusters") {
		resp := hapi.ClusterListResponse{
			Clusters: []string{"1"},
		}
		writeResp(w, http.StatusOK, resp, t)
		return
	}

	vol := strings.Split(strings.Trim(r.URL.String(), "/"), "/")
	if vol[0] == "volumes" {
		volID := vol[1]
		if resp, ok := volumeCache[volID]; ok {
			writeResp(w, http.StatusOK, resp, t)
		} else {
			w.WriteHeader(http.StatusNoContent)
		}
		return
	}
	if vol[0] == "clusters" {
		resp := hapi.ClusterInfoResponse{
			Id: vol[1],
			Nodes: []string{
				"node1",
				"node2",
				"node3",
			},
			Volumes: []string{},
		}
		writeResp(w, http.StatusOK, resp, t)
		return
	}
	if vol[0] == "nodes" {
		resp := hapi.NodeInfoResponse{
			NodeInfo: hapi.NodeInfo{
				Id: vol[1],
				NodeAddRequest: hapi.NodeAddRequest{
					Hostnames: hapi.HostAddresses{
						Manage:  []string{vol[1]},
						Storage: []string{vol[1]},
					},
				},
			},
		}
		writeResp(w, http.StatusOK, resp, t)
		return
	}
	writeResp(w, http.StatusNotFound, fmt.Sprintf("GET 404: %s", r.URL.String()), t)
}

func handleDELETERequest(w http.ResponseWriter, r *http.Request, t *testing.T) {
	glog.Errorf("DELETE URL: %s", r.URL.String())
	vol := strings.Split(strings.Trim(r.URL.String(), "/"), "/")
	if vol[0] == "volumes" {
		volID := vol[1]
		delete(volumeCache, volID)
		w.Header().Set("Location", fmt.Sprintf("/volumes/%s", volID))
		writeResp(w, http.StatusAccepted, nil, t)
		return
	}
	writeResp(w, http.StatusNotFound, fmt.Sprintf("DELETE 404: %s", r.URL.String()), t)
}

func handlePOSTRequest(w http.ResponseWriter, r *http.Request, t *testing.T) {
	glog.Errorf("POST URL: %v", r)
	//if strings.Contains(r.URL.String(), "/volumes") {
	if strings.HasSuffix(r.URL.String(), "/volumes") {
		defer r.Body.Close()

		var req hapi.VolumeCreateRequest
		json.NewDecoder(r.Body).Decode(&req)
		newID := fmt.Sprintf("%s-heketi", req.Name)
		resp := hapi.VolumeInfoResponse{
			VolumeInfo: hapi.VolumeInfo{
				VolumeCreateRequest: req,
				Id:                  newID,
			},
			Bricks: []hapi.BrickInfo{},
		}
		volumeCache[newID] = resp
		w.Header().Set("Location", fmt.Sprintf("/volumes/%s", newID))
		writeResp(w, http.StatusAccepted, nil, t)
		return
	}

	writeResp(w, http.StatusNotFound, fmt.Sprintf("POST 404: %v", r), t)
}

func writeResp(w http.ResponseWriter, status int, resp interface{}, t *testing.T) {
	w.WriteHeader(status)
	err := json.NewEncoder(w).Encode(&resp)
	if err != nil {
		t.Fatal("Failed to write response ", err)
	}
}
